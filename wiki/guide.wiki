#summary firefly使用指南
#labels Phase-Support
<wiki:toc max_depth="3" />
= 简介 =
 * firefly是一个追求高性能，精简轻量的应用程序框架
 * 包含IOC容器、Web应用MVC框架等
 * 默认使用Annotation配置方式


= 安装与配置 =
 # 把firefly.jar放入classpath下
 # 在classpath下创建firefly.properties文件
firefly.properties文件例子：
{{{
viewPath = /WEB-INF/page
componentPath = com.test.sample
encoding = UTF-8
}}}
firefly.properties配置说明：
|| * 配置项 * || * 说明 * || * 默认值 * ||
|| componentPath || firefly组件扫描包名，可以用逗号（,）分隔多个包 || 无 ||
|| viewPath （可选） || Web视图模版存储路径 || /WEB-INF/page ||
|| encoding （可选） || Web请求相应的字符集 || UTF-8 ||

= IOC =
[http://baike.baidu.com/view/1486379.htm IOC]为firefly的核心模块，使用类似Spring，默认使用Annotation配置方式，标注的组件生命周期为单例

== 声明一个组件 ==
例子：
{{{
@Component("addService")
public class AddServiceImpl implements AddService {

	@Override
	public int add(int x, int y) {
		return x + y;
	}

}
}}}

== 方法参数注入 ==
例子：
{{{
@Component("methodInject")
public class MethodInjectImpl implements MethodInject {
	private AddService addService;

	@Inject
	public void init(AddService addService) {
		this.addService = addService;
	}
}
}}}

== 属性注入 ==
例子：
{{{
@Component("fieldInject")
public class FieldInjectImpl implements FieldInject {

	@Inject
	private AddService addService;
	@Inject("addService")
	private AddService addService2;

	@Override
	public int add(int x, int y) {
		return addService.add(x, y);
	}

	@Override
	public int add2(int x, int y) {
		return addService2.add(x, y);
	}

}
}}}

= Web框架 =
使用[http://baike.baidu.com/view/31.htm MVC]模式，依赖firefly的IOC模块，默认使用Annotation配置方式
== 前端控制器 ==
在web.xml里面添加前端控制器
{{{
<servlet>
	<servlet-name>fireflyMVC</servlet-name>
	<servlet-class>com.firefly.mvc.web.servlet.DispatcherServlet</servlet-class>
	<!-- <init-param>
		<param-name>contextConfigLocation</param-name>
		<param-value>
			firefly_mvc.properties
		</param-value>
	</init-param> -->
	<load-on-startup>1</load-on-startup>
</servlet>
<servlet-mapping>
	<servlet-name>fireflyMVC</servlet-name>
	<url-pattern>/app/*</url-pattern>
</servlet-mapping>
}}}
== Controller使用 ==
例子：
{{{
@Controller
public class HelloController {
	@RequestMapping(value = "/hello")
	public String index(HttpServletRequest request) {

		request.setAttribute("hello", "你好 firefly!");

		return "/index.jsp";
	}

	@RequestMapping(value = "/hello1", view = View.TEXT)
	public String hello1(HttpServletResponse response,
			HttpServletRequest request) {

		return "测试一下";
	}

	@RequestMapping(value = "/hello5", view = View.REDIRECT)
	public String hello5(HttpServletRequest request,
			HttpServletResponse response) {
		return "/hello";
	}

	@RequestMapping(value = "/hello/json", view = View.JSON)
	public Object helloJson(HttpServletResponse response,
			HttpServletRequest request) {
		HelloJson helloJson = new HelloJson();
		helloJson.setId(3);
		helloJson.setText("测试json");
		return helloJson;
	}
}
}}}
 * @RequestMapping定义了请求地址和返回视图的类型，视图包括：jsp、text（文本）、redirect（重定向）、json
 * 当视图为jsp、text和redirect时方法的返回值约定为String类型，json支持Object类型

== 拦截器的使用 ==
例子：
{{{
@Interceptor(uri = "/hello*")
public class HelloInterceptor {
	private static Logger log = LoggerFactory.getLogger(HelloInterceptor.class);

	public void before(HttpServletRequest request, HttpServletResponse response) {
		log.info("before [{}]", request.getRequestURI());
	}

	public String after(HttpServletRequest request, HttpServletResponse response) {
		log.info("after [{}]", request.getRequestURI());
		return null;
	}
}
}}}

 * 拦截的uri支持使用“`*`”通配符
 * 拦截器约定方法名称为before和after，before为拦截到url请求时调用，after为controller执行之后并且在视图渲染之前调用
 * 拦截器能够改变被拦截的Controller的返回视图
例如：
{{{
@Interceptor(uri = "/ti", view = View.REDIRECT)
public class Hello2Interceptor {
	private static Logger log = LoggerFactory
			.getLogger(Hello2Interceptor.class);

	public String before(HttpServletRequest request,
			HttpServletResponse response) {
		log.info("ti before [{}]", request.getRequestURI());
		return "/hello2";
	}

	public String after(HttpServletRequest request, HttpServletResponse response) {
		log.info("ti after [{}]", request.getRequestURI());
		return "/hello3";
	}
}
}}}
当“/ti”对应的controller执行之后，返回的视图将变成拦截器返回的视图