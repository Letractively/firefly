#summary firefly使用指南
#labels Phase-Support
<wiki:toc max_depth="3" />
= 特性 =
 * 高性能，性能大幅超越spring3、struts2
 * 零依赖，仅仅依赖于jdk
 * 精简、轻量、无侵入
 * core包含IOC、MVC、Interceptor等常用功能
 * 使用简单，基于约定优于配置的思想，可完全使用Annotation方式 或 Annotation和XML混合方式 进行配置

= IOC =
[http://baike.baidu.com/view/1486379.htm IOC]为firefly的核心模块，使用类似Spring，使用Annotation或XML配置方式，组件生命周期为单例。
== xml组件声明 ==
 # 把firefly.jar放入classpath下
 # 在classpath下创建firefly.xml文件
firefly.xml文件例子：
{{{
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://code.google.com/p/firefly/beans"
		xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
		xsi:schemaLocation="http://code.google.com/p/firefly/beans 
http://firefly.googlecode.com/files/beans.xsd">

	<import resource="fruit.xml"/>
	<component-scan base-package="test.mixed"/>

	<bean id="foodRepository" class="test.mixed.impl.FoodRepositoryImpl">
		<property name="food">
			<list>
				<ref bean="apple"/>
				<ref bean="orange"/>
				<ref bean="strawberry"/>
			</list>
		</property>
	</bean>

</beans>
}}}
firefly.xml配置说明：
 # {{{ <import/> }}} 节点用来引入其他配置文件，可以声明多个引入多个配置xml文件
 # {{{ <component-scan/> }}} 节点用来配置Annotation组件声明，表示annotation包扫描路径，可以配置多个component-scan节点，表示对多个包进行扫描。
 # {{{ <bean/> }}} 节点把 test.mixed.impl.FoodRepositoryImpl 声明成一个组件，id属性是可选的，不填写的时候只能按接口类型获取bean。
 # {{{ <property/> }}} 节点通过name属性指定javabean中的set方法给组件进行依赖注入。
 # {{{ <property/> }}} 节点下可选节点有{{{<value/><ref/><list/><array/><map/>}}}节点。
   * {{{ <value/> }}} 直接注入字面值，并且会根据其字面值自动判断类型，或者通过type属性声明value的类型
   * {{{ <ref/> }}} 注入其他声明过的组件
   * {{{ <list/> }}} 注入Collection接口的各种实现类，会自动匹配set方法参数类型，或者通过type指定特定类型的Collection实现类
   * {{{ <array/> }}} 注入数组类型，会自动匹配set方法参数类型
   * {{{ <map/> }}} 注入Map接口的各种实现类，可以通过type指定特定的map接口实现类，没有指定type时自动匹配set方法参数的类型
具体的xml配置参数可以参看 [http://firefly.googlecode.com/files/beans.xsd schema定义]

== annotation声明组件 ==
例子：
{{{
@Component("foodService")
public class FoodServiceImpl implements FoodService {

	@Inject
	private FoodRepository foodRepository;

	@Override
	public Food getFood(String name) {
		for (Food f : foodRepository.getFood()) {
			if (f.getName().equals(name))
				return f;
		}
		return null;
	}

}
}}}
@Component("foodService") 其中foodService对应xml声明中的bean id，这是可选项，不填写这一项的时候无法通过id获取bean，但可以按类型自动获取bean。其中FoodRepository组件是先前在firefly.xml中声明的，xml和annotation声明组件是等效的，在同一个上下文中，能互相注入。当这两种声明方式发生冲突时，ApplicationContext启动过程当中抛出BeanDefinitionParsingException异常。

 * 方法参数注入
例子：
{{{
@Component("methodInject")
public class MethodInjectImpl implements MethodInject {
	private AddService addService;

	@Inject
	public void init(AddService addService) {
		this.addService = addService;
	}
}
}}}
方法参数只支持按类型自动注入

 * 属性注入
例子：
{{{
@Component("fieldInject")
public class FieldInjectImpl implements FieldInject {

	@Inject
	private AddService addService;
	@Inject("addService")
	private AddService addService2;

	......
}
}}}
属性支持按照属性类型自动注入或者按组件id的方式注入

== 创建IOC容器 ==
例子：
{{{
	public static ApplicationContext applicationContext = new XmlApplicationContext(
			"firefly.xml");

	@Test
	public void testInject() {
		FoodService foodService = applicationContext.getBean("foodService");
		Food food = foodService.getFood("apple");
		log.debug(food.getName());
		Assert.assertThat(food.getPrice(), is(5.3));
		
		foodService = applicationContext.getBean(FoodService.class);
		food = foodService.getFood("strawberry");
		log.debug(food.getName());
		Assert.assertThat(food.getPrice(), is(10.00));
	}
}}}
支持根据Bean Id获取bean，或者通过接口的类型自动获取bean：
 # applicationContext.getBean("foodService");使用id获取bean实例对象
 # applicationContext.getBean(FoodService.class);根据类型自动找到实例对象

= Web框架 =
使用[http://baike.baidu.com/view/31.htm MVC]模式，依赖firefly的IOC模块，使用Annotation配置方式
== 前端控制器 ==
在web.xml里面添加前端控制器，默认读取的配置文件为firefly.xml，也可以通过init-param自定义配置文件名
{{{
<servlet>
	<servlet-name>fireflyMVC</servlet-name>
	<servlet-class>com.firefly.mvc.web.servlet.DispatcherServlet</servlet-class>
	<!-- <init-param>
		<param-name>contextConfigLocation</param-name>
		<param-value>
			firefly_mvc.xml
		</param-value>
	</init-param> -->
	<load-on-startup>1</load-on-startup>
</servlet>
<servlet-mapping>
	<servlet-name>fireflyMVC</servlet-name>
	<url-pattern>/app/*</url-pattern>
</servlet-mapping>
}}}

firefly.xml配置文件
{{{
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://code.google.com/p/firefly/beans"
		xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
		xsi:schemaLocation="http://code.google.com/p/firefly/beans 
http://firefly.googlecode.com/files/beans.xsd">

	<component-scan base-package="com.test.sample"/>
	<mvc view-path="/WEB-INF/page" view-encoding="UTF-8"/>

</beans>
}}}
{{{<mvc/>}}}节点有两个属性，view-path表示jsp视图存放的路径，view-encoding为返回视图的字符集

== Controller使用 ==
 * @RequestMapping定义了请求地址和返回视图的类型，视图包括：jsp、text（文本）、redirect（重定向）、json
 * 当视图为jsp、text和redirect时方法的返回值约定为String类型，json支持Object类型
例子：
{{{
@Controller
public class HelloController {
	@RequestMapping(value = "/hello")
	public String index(HttpServletRequest request) {

		request.setAttribute("hello", "你好 firefly!");

		return "/index.jsp";
	}

	@RequestMapping(value = "/hello1", view = View.TEXT)
	public String hello1(HttpServletResponse response,
			HttpServletRequest request) {

		return "测试一下";
	}

	@RequestMapping(value = "/hello5", view = View.REDIRECT)
	public String hello5(HttpServletRequest request,
			HttpServletResponse response) {
		return "/hello";
	}

	@RequestMapping(value = "/hello/json", view = View.JSON)
	public Object helloJson(HttpServletResponse response,
			HttpServletRequest request) {
		HelloJson helloJson = new HelloJson();
		helloJson.setId(3);
		helloJson.setText("测试json");
		return helloJson;
	}
}
}}}

== 自动封装request参数到javabean ==
 * 自动封装请求参数到javabean，只要把方法的参数标记上@HttpParam即可，@HttpParam.value()是可选值，当不为空的时候会自动把Book对象setAttribute里面
{{{
	@RequestMapping(value = "/book/add")
	public String gotoCreateBook() {
		return "/book_create.jsp";
	}

	@RequestMapping(value = "/book/create", method = HttpMethod.POST)
	public String createBook(@HttpParam("book") Book book) {
		book.setSell(true);
		book.setText("测试当前book");
		book.setId(90);
		return "/book.jsp";
	}
}}}

页面book.jsp
{{{
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Strict//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html>
<head>
<title>firefly</title>
</head>
<body>
| ${book.id} | ${book.title} | ${book.text} | ${book.price} | ${book.sell} |
</body>
</html>
}}}

页面book_create.jsp
{{{
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Strict//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html>
<head>
<title>firefly</title>
</head>
<body>
<form action="<c:url value="/app/book/create"></c:url>" method="POST">
	书名：<input type="text" name="title"></input><br/>
	价格：<input type="text" name="price"></input><br/>
	<input type="submit" value="提交"></input>
</form>
</body>
</html>
}}}

输入价格：324 书名：fdsfsdf 后显示结果

{{{
| 90 | fdsfsdf | 测试当前book | 324.0 | true | 
}}}

== 灵活的controller方法参数 ==
 * controller的方法参数里面可以注入 request、response 或 标注有@HttpParam 的对象，可以灵活组合
例如：
{{{
	@RequestMapping(value = "/hello/value")
	public String helloValue(HttpServletRequest request, @HttpParam Book book) {
		request.setAttribute("book", book);
		return "/book.jsp";
	}
}}}


== 拦截器的使用 ==
 * 拦截的uri支持使用“`*`”通配符
 * 拦截器约定方法名称为before和after，before为拦截到url请求时调用，after为controller执行之后并且在视图渲染之前调用
例子：
{{{
@Interceptor(uri = "/hello*")
public class HelloInterceptor {
	private static Logger log = LoggerFactory.getLogger(HelloInterceptor.class);

	public void before(HttpServletRequest request, HttpServletResponse response) {
		log.info("before [{}]", request.getRequestURI());
	}

	public String after(HttpServletRequest request, HttpServletResponse response) {
		log.info("after [{}]", request.getRequestURI());
		return null;
	}
}
}}}
 
 * 拦截器能够改变被拦截的Controller的返回视图
例子：
{{{
@Interceptor(uri = "/ti", view = View.REDIRECT)
public class Hello2Interceptor {
	private static Logger log = LoggerFactory
			.getLogger(Hello2Interceptor.class);

	public String before(HttpServletRequest request,
			HttpServletResponse response) {
		log.info("ti before [{}]", request.getRequestURI());
		return "/hello2";
	}

	public String after(HttpServletRequest request, HttpServletResponse response) {
		log.info("ti after [{}]", request.getRequestURI());
		return "/hello3";
	}
}
}}}
当“/ti”对应的controller执行之后，返回的视图将变成拦截器返回的视图，拦截器return null或者返回值为void时拦截栈会继续执行，有返回值的情况下会中断拦截栈，直接渲染拦截器返回的视图。

 * 通过order定义拦截器执行顺序，order越小拦截器越先执行，order默认值为0
例子：
{{{
@Interceptor(uri = "/itest*/t*", order = 1)
public class ItestInterceptor {
	private static Logger log = LoggerFactory.getLogger(ItestInterceptor.class);

	public void before(HttpServletRequest request, HttpServletResponse response) {
		log.info("before 1 [{}]", request.getRequestURI());
	}

	public String after(HttpServletRequest request, HttpServletResponse response) {
		log.info("after 1 [{}]", request.getRequestURI());
		return null;
	}
}

@Interceptor(uri = "/itest*")
public class HelloInterceptor {
	private static Logger log = LoggerFactory.getLogger(HelloInterceptor.class);

	public void before(HttpServletRequest request, HttpServletResponse response) {
		log.info("before 0 [{}]", request.getRequestURI());
	}

	public String after(HttpServletRequest request, HttpServletResponse response) {
		log.info("after 0 [{}]", request.getRequestURI());
		return null;
	}
}
}}}
这两个拦截器拦截的controller为：
{{{
	@RequestMapping(value = "/itest2/t2")
	public String index2(HttpServletRequest request) {
		request.setAttribute("hello", "你好 itest2!");
		return "/index.jsp";
	}
}}}

最后log打印信息如下：
{{{
[com.test.sample.interceptor.HelloInterceptor]-[INFO]-2011-01-02 22:07:17,976 ## before 0 [/firefly-demo/app/itest2/t2]
[com.test.sample.interceptor.ItestInterceptor]-[INFO]-2011-01-02 22:07:17,976 ## before 1 [/firefly-demo/app/itest2/t2]
[com.test.sample.interceptor.ItestInterceptor]-[INFO]-2011-01-02 22:07:17,976 ## after 1 [/firefly-demo/app/itest2/t2]
[com.test.sample.interceptor.HelloInterceptor]-[INFO]-2011-01-02 22:07:17,976 ## after 0 [/firefly-demo/app/itest2/t2]
}}}